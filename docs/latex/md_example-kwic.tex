{\bfseries{Table of Contents}} {\itshape generated with \href{https://github.com/thlorenz/doctoc}{\texttt{ Doc\+Toc}}}


\begin{DoxyItemize}
\item \href{\#example-a-kwic-like-greeting-program}{\texttt{ Example\+: a K\+W\+I\+C-\/like greeting program}}
\begin{DoxyItemize}
\item \href{\#1--the-ascii-based-variant}{\texttt{ 1 – The A\+S\+C\+I\+I-\/based variant.}}
\item \href{\#11---and-one-include-to-bind-them-all}{\texttt{ 1.\+1 – “… and one {\ttfamily \#include} to bind them all”.}}
\item \href{\#12--an-app-namespace}{\texttt{ 1.\+2 – An {\ttfamily app} namespace.}}
\item \href{\#13--using-declaring-names-from-libraries}{\texttt{ 1.\+3 – {\ttfamily using}-\/declaring names from libraries.}}
\item \href{\#14--throwing-an-exception-via-the-fail-macro}{\texttt{ 1.\+4 – Throwing an exception via the {\ttfamily \$fail} macro.}}
\item \href{\#15---using-the-cppx-core-support-for-signed-integer-arithmetic}{\texttt{ 1.\+5 – Using the {\itshape cppx-\/core} support for signed integer arithmetic.}}
\item \href{\#16--using-the-cppx-core-ascii-support}{\texttt{ 1.\+6 – Using the {\itshape cppx-\/core} A\+S\+C\+II support.}}
\item \href{\#17--the-items-macro}{\texttt{ 1.\+7 – The {\ttfamily \$items} macro.}}
\end{DoxyItemize}
\end{DoxyItemize}

\section*{Example\+: a K\+W\+I\+C-\/like greeting program}

This example is a possible code part of an answer on a Q\&A site such as Stack Overflow, or in a response in a technical discussion e.\+g. on Reddit.

The program (perhaps a student exercise) asks for the user\textquotesingle{}s name and if that name contains one or more repeated characters it reports one that has the maximum count, as the most common character in the name, and then presents the name repeatedly but offset horizontally so that occurrences of that character line up vertically\+:

\begin{quote}
{\ttfamily $>$$>$$>$ The K\+W\+I\+C-\/like personal greeting program, using A\+S\+C\+I\+I! $<$$<$$<$}

{\ttfamily Hi, what\textquotesingle{}s your name (in lowercase \& English letters only please)}

{\ttfamily ?} {\itshape {\bfseries{alfa bravo charlie}}}

{\ttfamily Oh hi, alfa bravo charlie! Nice to meet you!}

`The/a most common character in your name is \textquotesingle{}a'\+:\`{}

{\ttfamily ~~~~~~~~~~~~~$\vert$a$\vert$lfa bravo charlie}

{\ttfamily ~~~~~~~~~~alf$\vert$a$\vert$ bravo charlie}

{\ttfamily ~~~~~~alfa br$\vert$a$\vert$vo charlie}

{\ttfamily alfa bravo ch$\vert$a$\vert$rlie}

\end{quote}


The example interaction above is for the A\+S\+C\+II text encoding variant of the program. A\+S\+C\+II text uses only one byte per character, one {\ttfamily char} value per character, which gives simpler code than with the more general U\+T\+F-\/8 encoding. The U\+T\+F-\/8 based variant is slightly more complicated, and so even though I did that first here it\textquotesingle{}s presented last.

By the way, “\+K\+W\+I\+C” means {\itshape key word in context}.

It was once a popular exercise for students, similar to this example, but with a key word lining up vertically instead of just a single character.

\subsection*{1 – The A\+S\+C\+I\+I-\/based variant.}


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{// → examples/kwic-greeting/kwic-greeting.ascii.cpp}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <cppx-core/\_all\_.hpp>}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{namespace }app}
\DoxyCodeLine{\{}
\DoxyCodeLine{    \$use\_cppx(}
\DoxyCodeLine{        Index, is\_ascii\_whitespace, is\_empty, length\_of, Map\_, n\_items\_in, spaces}
\DoxyCodeLine{        );}
\DoxyCodeLine{    \$use\_std(}
\DoxyCodeLine{        cin, cout, end, endl, getline, \textcolor{keywordtype}{string}, string\_view, max\_element, vector}
\DoxyCodeLine{        );}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{keyword}{auto} input() -> \textcolor{keywordtype}{string}}
\DoxyCodeLine{    \{}
\DoxyCodeLine{        \textcolor{keywordtype}{string} result;}
\DoxyCodeLine{        getline( cin, result )}
\DoxyCodeLine{            or \$fail( \textcolor{stringliteral}{"std::getline failed on std::cin"} );}
\DoxyCodeLine{        \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{    \}}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{keyword}{using} Char\_indices = Map\_<char, vector<Index>>;     \textcolor{comment}{// “ASCII code point” → “indices”}}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{keyword}{auto} char\_indices\_in( \textcolor{keyword}{const} string\_view\& s )}
\DoxyCodeLine{        -> Char\_indices}
\DoxyCodeLine{    \{}
\DoxyCodeLine{        Char\_indices result;}
\DoxyCodeLine{        \textcolor{keywordflow}{for}( Index i = 0; i < length\_of( s ); ++i )}
\DoxyCodeLine{        \{}
\DoxyCodeLine{            \textcolor{keyword}{const} \textcolor{keywordtype}{char} ch = s[i];}
\DoxyCodeLine{            \textcolor{keywordflow}{if}( not is\_ascii\_whitespace( ch ) )}
\DoxyCodeLine{            \{}
\DoxyCodeLine{                result[ch].push\_back( i );}
\DoxyCodeLine{            \}}
\DoxyCodeLine{        \}}
\DoxyCodeLine{        \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{    \}}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{keywordtype}{void} run()}
\DoxyCodeLine{    \{}
\DoxyCodeLine{        cout << \textcolor{stringliteral}{">>> The KWIC-like personal greeting program, using ASCII! <<<"} << endl;}
\DoxyCodeLine{        cout << \textcolor{stringliteral}{"Hi, what's your name (in lowercase \& English letters only please)\(\backslash\)n? "};}
\DoxyCodeLine{        \textcolor{keyword}{const} \textcolor{keywordtype}{string} username = input();}
\DoxyCodeLine{}
\DoxyCodeLine{        \textcolor{keyword}{const} Char\_indices  char\_indices    = char\_indices\_in( username );}
\DoxyCodeLine{        \textcolor{keyword}{const} \textcolor{keyword}{auto}          it\_most\_common  = max\_element( \$items( char\_indices ),}
\DoxyCodeLine{            []( \textcolor{keyword}{auto}\& a, \textcolor{keyword}{auto}\& b ) \{ \textcolor{keywordflow}{return} a.second.size() < b.second.size(); \}}
\DoxyCodeLine{            );}
\DoxyCodeLine{}
\DoxyCodeLine{        cout << endl;}
\DoxyCodeLine{        \textcolor{keywordflow}{if}( it\_most\_common == end( char\_indices ) )     \textcolor{comment}{// Username empty or all spaces.}}
\DoxyCodeLine{        \{}
\DoxyCodeLine{            cout << \textcolor{stringliteral}{"Have a nice day!"} << endl;}
\DoxyCodeLine{            \textcolor{keywordflow}{return};}
\DoxyCodeLine{        \}}
\DoxyCodeLine{}
\DoxyCodeLine{        \textcolor{keyword}{const} \textcolor{keywordtype}{char} ch       = it\_most\_common->first;}
\DoxyCodeLine{        \textcolor{keyword}{const} \textcolor{keyword}{auto}\& indices = it\_most\_common->second;}
\DoxyCodeLine{}
\DoxyCodeLine{        \textcolor{keywordflow}{if}( n\_items\_in( indices ) == 1 )}
\DoxyCodeLine{        \{}
\DoxyCodeLine{            cout << \textcolor{stringliteral}{"All characters in your name are unique, "} << username << \textcolor{stringliteral}{"."} << endl;}
\DoxyCodeLine{            \textcolor{keywordflow}{return};}
\DoxyCodeLine{        \}}
\DoxyCodeLine{}
\DoxyCodeLine{        cout << \textcolor{stringliteral}{"Oh hi, "} << username << \textcolor{stringliteral}{"! Nice to meet you!"} << endl;}
\DoxyCodeLine{        cout << \textcolor{stringliteral}{"The/a most common character in your name is '"} << ch << \textcolor{stringliteral}{"':"} << endl;}
\DoxyCodeLine{        cout << endl;}
\DoxyCodeLine{        \textcolor{keyword}{const} Index max\_index = indices.back();}
\DoxyCodeLine{        \textcolor{keywordflow}{for}( \textcolor{keyword}{const} Index i: indices )}
\DoxyCodeLine{        \{}
\DoxyCodeLine{            cout    << spaces( max\_index - i )}
\DoxyCodeLine{                    << username.substr( 0, i )}
\DoxyCodeLine{                    << \textcolor{stringliteral}{"|"} << ch << \textcolor{stringliteral}{"|"}}
\DoxyCodeLine{                    << username.substr( i + 1 )}
\DoxyCodeLine{                    << endl;}
\DoxyCodeLine{        \}}
\DoxyCodeLine{    \}}
\DoxyCodeLine{\}  \textcolor{comment}{// namespace app}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{auto} main() -> \textcolor{keywordtype}{int}}
\DoxyCodeLine{\{}
\DoxyCodeLine{    \$use\_cppx( description\_lines\_from, monospaced\_bullet\_block );}
\DoxyCodeLine{    \$use\_std( cerr, endl, exception, \textcolor{keywordtype}{string} );}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{keywordflow}{try}}
\DoxyCodeLine{    \{}
\DoxyCodeLine{        app::run();}
\DoxyCodeLine{        \textcolor{keywordflow}{return} EXIT\_SUCCESS;}
\DoxyCodeLine{    \}}
\DoxyCodeLine{    \textcolor{keywordflow}{catch}( \textcolor{keyword}{const} exception\& x )}
\DoxyCodeLine{    \{}
\DoxyCodeLine{        \textcolor{keyword}{const} \textcolor{keywordtype}{string} text = description\_lines\_from( x );}
\DoxyCodeLine{        cerr << \textcolor{stringliteral}{"\(\backslash\)n"} << monospaced\_bullet\_block( text, \textcolor{stringliteral}{"!"} ) << endl;}
\DoxyCodeLine{    \}}
\DoxyCodeLine{    \textcolor{keywordflow}{return} EXIT\_FAILURE;}
\DoxyCodeLine{\}}
\end{DoxyCode}


\subsection*{1.\+1 – “… and one {\ttfamily \#include} to bind them all”.}

Code\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <cppx-core/\_all\_.hpp>}}
\end{DoxyCode}


This line includes everything from the library, including a guaranteed set of standard library headers.

Every folder in {\itshape cppx-\/core} has an {\itshape {\bfseries{\+\_\+all\+\_\+.\+hpp}}} file that includes everything in that folder and subfolders. Thus, using the top level $\ast$\+\_\+all\+\_\+.hpp$\ast$ file includes everything. You can include smaller subsets by including a sub-\/folder\textquotesingle{}s $\ast$\+\_\+all\+\_\+.hpp$\ast$, or a specific header (they\textquotesingle{}re all self-\/sufficient, with no requirements), or at the top level you can alternatively include {\itshape {\bfseries{all-\/except-\/io.\+hpp}}}.

The guaranteed set of standard library headers is provided by


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <cppx-core/stdlib-includes/basic-general.hpp>}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <cppx-core/stdlib-includes/basic-io.hpp>}}
\end{DoxyCode}


The non-\/i/o headers provided by {\itshape stdlib-\/includes/basic-\/general.\+hpp} are generally those that correspond to either C++ core langauge features, or to core language features in some other similar languages like Java and C\#\+:


\begin{DoxyItemize}
\item $\ast$$<$algorithm$>$$\ast$, $\ast$$<$array$>$$\ast$, $\ast$$<$atomic$>$$\ast$, $\ast$$<$chrono$>$$\ast$, $\ast$$<$deque$>$$\ast$, $\ast$$<$functional$>$$\ast$, $\ast$$<$initializer\+\_\+list$>$$\ast$, $\ast$$<$iosfwd$>$$\ast$, $\ast$$<$iterator$>$$\ast$, $\ast$$<$map$>$$\ast$, $\ast$$<$memory$>$$\ast$, $\ast$$<$mutex$>$$\ast$, $\ast$$<$numeric$>$$\ast$, $\ast$$<$optional$>$$\ast$, $\ast$$<$queue$>$$\ast$, $\ast$$<$random$>$$\ast$, $\ast$$<$set$>$$\ast$, $\ast$$<$stack$>$$\ast$, $\ast$$<$stdexcept$>$$\ast$, $\ast$$<$string$>$$\ast$, $\ast$$<$string\+\_\+view$>$$\ast$, $\ast$$<$thread$>$$\ast$, $\ast$$<$unordered\+\_\+map$>$$\ast$, $\ast$$<$unordered\+\_\+set$>$$\ast$, $\ast$$<$utility$>$$\ast$, $\ast$$<$vector$>$$\ast$.
\end{DoxyItemize}

The i/o headers provided by {\itshape stdlib-\/includes/basic-\/io.\+hpp} are just all the C++17 i/o headers, because there are just a few\+:


\begin{DoxyItemize}
\item $\ast$$<$filesystem$>$$\ast$, $\ast$$<$fstream$>$$\ast$, $\ast$$<$iomanip$>$$\ast$, $\ast$$<$iostream$>$$\ast$, $\ast$$<$sstream$>$$\ast$.
\end{DoxyItemize}

Note\+: the $\ast$$<$iostream$>$$\ast$ header guaranteed includes $\ast$$<$ios$>$$\ast$, $\ast$$<$streambuf$>$$\ast$, $\ast$$<$istream$>$$\ast$ and $\ast$$<$ostream$>$$\ast$, so you get those too.

\subsection*{1.\+2 – An {\ttfamily app} namespace.}

Code\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{namespace }app}
\DoxyCodeLine{\{}
\DoxyCodeLine{    ⋮}
\DoxyCodeLine{\}  \textcolor{comment}{// namespace app}}
\end{DoxyCode}


With {\itshape cppx-\/core} it\textquotesingle{}s easy to {\ttfamily using}-\/declare identifiers from other namespaces, and that\textquotesingle{}s best done within your own namespace, not in the global namespace.

In particular, introducing identifiers directly into the global namespace can be problematic in a header.

So, in order to keep to good programming practices that work in general, I here use an {\ttfamily app} namespace for everything but the {\ttfamily main} function.

\subsection*{1.\+3 – {\ttfamily using}-\/declaring names from libraries.}

Code\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\$use\_cppx(}
\DoxyCodeLine{    Index, is\_ascii\_whitespace, is\_empty, length\_of, Map\_, n\_items\_in, spaces}
\DoxyCodeLine{    );}
\DoxyCodeLine{\$use\_std(}
\DoxyCodeLine{    cin, cout, end, endl, getline, \textcolor{keywordtype}{string}, string\_view, max\_element, vector}
\DoxyCodeLine{    );}
\end{DoxyCode}


The $\ast$$\ast${\ttfamily \$use\+\_\+cppx}$\ast$$\ast$ macro is a more readable non-\/shouting alias for {\ttfamily C\+P\+P\+X\+\_\+\+U\+S\+E\+\_\+\+C\+P\+PX}, and ditto, $\ast$$\ast${\ttfamily \$use\+\_\+std}$\ast$$\ast$ is a more readable non-\/shouting alias for {\ttfamily C\+P\+P\+X\+\_\+\+U\+S\+E\+\_\+\+S\+TD}. They {\ttfamily using}-\/declare the specified names, from respectively the {\ttfamily cppx} and {\ttfamily std} namespaces. The $\ast$$\ast${\ttfamily cppx} namespace$\ast$$\ast$ contains stuff from the {\itshape cppx-\/core} (and later also the {\itshape C++ Band Aid}) library, and the {\ttfamily std} namespace contains stuff from the C++ standard library.

Both macros are defined in terms of the more general {\ttfamily C\+P\+P\+X\+\_\+\+U\+S\+E\+\_\+\+F\+R\+O\+M\+\_\+\+N\+A\+M\+E\+S\+P\+A\+CE}, alias $\ast$$\ast${\ttfamily \$use\+\_\+from\+\_\+namespace}$\ast$$\ast$, which you can use to {\ttfamily using}-\/declare names from other namespaces. There\textquotesingle{}s also {\ttfamily C\+P\+P\+X\+\_\+\+U\+S\+E\+\_\+\+N\+A\+M\+E\+S\+P\+A\+C\+E\+\_\+\+N\+A\+M\+E\+\_\+\+IN}, alias $\ast$$\ast${\ttfamily \$use\+\_\+namespace\+\_\+name\+\_\+in}$\ast$$\ast$, which you can use to {\ttfamily namespace}-\/declare the name of a nested namespace. These macros are provided by {\itshape syntax/macro-\/use.\+hpp}.

\subsection*{1.\+4 – Throwing an exception via the {\ttfamily \$fail} macro.}

Code\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{auto} input() -> \textcolor{keywordtype}{string}}
\DoxyCodeLine{\{}
\DoxyCodeLine{    \textcolor{keywordtype}{string} result;}
\DoxyCodeLine{    getline( cin, result )}
\DoxyCodeLine{        or \$fail( \textcolor{stringliteral}{"std::getline failed on std::cin"} );}
\DoxyCodeLine{    \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{\}}
\end{DoxyCode}


By default $\ast$$\ast${\ttfamily \$fail}$\ast$$\ast$ throws a {\ttfamily std\+::runtime\+\_\+error} exception with the source code location embedded in the exception message as a second and indented line.

{\ttfamily \$fail} ends up using $\ast$$\ast${\ttfamily cppx\+::fail}$\ast$$\ast$ to throw the exception. And the {\ttfamily cppx\+::fail} function has {\ttfamily bool} return type, though it never returns!, in order to facilitate usage like the “{\ttfamily … or \$fail}” pattern above. When it\textquotesingle{}s used within a {\ttfamily catch} block then the current exception is nested via the standard C++11 mechanism.

In this example there\textquotesingle{}s no exception nesting, and the message can look like this (here running the program in Windows)\+:

\begin{quote}
{\ttfamily $>$$>$$>$ The K\+W\+I\+C-\/like personal greeting program, using A\+S\+C\+I\+I! $<$$<$$<$}

{\ttfamily Hi, what\textquotesingle{}s your name (in lowercase \& English letters only please)}

{\ttfamily ?} {\itshape {\bfseries{$^\wedge$Z}}}

{\ttfamily !~~~input -\/ std\+::getline failed on std\+::cin}

{\ttfamily ~~~~~~~~$>$File \char`\"{}kwic-\/greeting.\+ascii.\+cpp\char`\"{} at line 17}

\end{quote}


The $\ast$$\ast${\ttfamily $^\wedge$Z}$\ast$$\ast$ is from typing a {\ttfamily Ctrl}+{\ttfamily Z}, which in Windows signifies end-\/of-\/text, like an end-\/of-\/file.

Fine point\+: in order to get straight A\+S\+C\+II quote characters, like $\ast$$\ast${\ttfamily "}$\ast$$\ast$, I defined $\ast$$\ast${\ttfamily C\+P\+P\+X\+\_\+\+U\+S\+E\+\_\+\+A\+S\+C\+I\+I\+\_\+\+P\+L\+E\+A\+SE}$\ast$$\ast$ when I built the program. The default roundish U\+T\+F-\/8 encoded quote characters don\textquotesingle{}t play well in an ordinary non-\/\+W\+SL Windows console window, even with active codepage 65001. Instead of the macro symbol definition I could have provided a custom {\itshape config.\+hpp} file via an include path override, or I could have edited the default one.

\subsection*{1.\+5 – Using the {\itshape cppx-\/core} support for signed integer arithmetic.}

Code\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{using} Char\_indices = Map\_<char, vector<Index>>;}
\end{DoxyCode}


You can think of the {\itshape cppx-\/core} $\ast$$\ast${\ttfamily Map\+\_\+}$\ast$$\ast$ class template as an alias for {\ttfamily std\+::unordered\+\_\+map}. Actually it\textquotesingle{}s a derived class in order to provide the missing {\ttfamily \mbox{[}\mbox{]}} indexing operator for a {\ttfamily const} {\ttfamily unordered\+\_\+map} object, so more precisely it\textquotesingle{}s like an alias for an {\ttfamily unordered\+\_\+map} with more uniform access notation. So, a variable of type {\ttfamily Char\+\_\+indices} is a set of pairs, where each pair contains a {\ttfamily char} value and a corresponding {\ttfamily vector} of indices.

The {\itshape cppx-\/core} $\ast$$\ast${\ttfamily Index}$\ast$$\ast$ type is an alias for the standard library\textquotesingle{}s {\ttfamily ptrdiff\+\_\+t} type. I.\+e. it\textquotesingle{}s a signed index type of maximal practical range with a self-\/descriptive name. {\itshape cppx-\/core} also provides a signed size type called $\ast$$\ast${\ttfamily Size}$\ast$$\ast$, that\textquotesingle{}s also just an alias for {\ttfamily ptrdiff\+\_\+t}. With signed types one avoids some nasty bugs associated with implicit conversions from signed to unsigned type, and resulting wrap-\/around to Really Large\texttrademark{} values. To avoid signed/unsigned mismatch warnings these types are supported by signed result functions such as $\ast$$\ast${\ttfamily n\+\_\+items\+\_\+of}$\ast$$\ast$ and (for strings) $\ast$$\ast${\ttfamily length\+\_\+of}$\ast$$\ast$.

\subsection*{1.\+6 – Using the {\itshape cppx-\/core} A\+S\+C\+II support.}

Code\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{auto} char\_indices\_in( \textcolor{keyword}{const} string\_view\& s )}
\DoxyCodeLine{    -> Char\_indices}
\DoxyCodeLine{\{}
\DoxyCodeLine{    Char\_indices result;}
\DoxyCodeLine{    \textcolor{keywordflow}{for}( Index i = 0; i < length\_of( s ); ++i )}
\DoxyCodeLine{    \{}
\DoxyCodeLine{        \textcolor{keyword}{const} \textcolor{keywordtype}{char} ch = s[i];}
\DoxyCodeLine{        \textcolor{keywordflow}{if}( not is\_ascii\_whitespace( ch ) )}
\DoxyCodeLine{        \{}
\DoxyCodeLine{            result[ch].push\_back( i );}
\DoxyCodeLine{        \}}
\DoxyCodeLine{    \}}
\DoxyCodeLine{    \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{\}}
\end{DoxyCode}


The only new {\itshape cppx-\/core} thing in this snippet is the $\ast$$\ast${\ttfamily is\+\_\+ascii\+\_\+whitespace}$\ast$$\ast$ function. Other functions that provide A\+S\+C\+II support include {\ttfamily is\+\_\+all\+\_\+ascii\+\_\+whitespace}, {\ttfamily is\+\_\+ascii}, {\ttfamily is\+\_\+all\+\_\+ascii}, {\ttfamily wide\+\_\+from\+\_\+ascii}, {\ttfamily is\+\_\+ascii\+\_\+lowercase}, {\ttfamily is\+\_\+ascii\+\_\+uppercase}, {\ttfamily ascii\+\_\+to\+\_\+lowercase}, {\ttfamily ascii\+\_\+to\+\_\+uppercase}, and {\ttfamily ascii\+\_\+quoted}. Since these functions are restricted to A\+S\+C\+II they\textquotesingle{}re locale independent\+: you get the same results always.

I chose to express the above with an indexing loop using a classic {\ttfamily for}, computing each item value from the index. Alternatively the loop can be written as a range based {\ttfamily for} producing item references, and computing each index from the item reference. In the Python language one would naturally loop over the {\ttfamily enumerate}d pairs of item and index, but {\itshape cppx-\/core} doesn\textquotesingle{}t offer that functionality\+: it may be provided in the future, or by the {\itshape C++ Band Aid} library.

\subsection*{1.\+7 – The {\ttfamily \$items} macro.}

Code\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordtype}{void} run()}
\DoxyCodeLine{\{}
\DoxyCodeLine{    cout << \textcolor{stringliteral}{">>> The KWIC-like personal greeting program, using ASCII! <<<"} << endl;}
\DoxyCodeLine{    cout << \textcolor{stringliteral}{"Hi, what's your name (in lowercase \& English letters only please)\(\backslash\)n? "};}
\DoxyCodeLine{    \textcolor{keyword}{const} \textcolor{keywordtype}{string} username = input();}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{keyword}{const} Char\_indices  char\_indices    = char\_indices\_in( username );}
\DoxyCodeLine{    \textcolor{keyword}{const} \textcolor{keyword}{auto}          it\_most\_common  = max\_element( \$items( char\_indices ),}
\DoxyCodeLine{        []( \textcolor{keyword}{auto}\& a, \textcolor{keyword}{auto}\& b ) \{ \textcolor{keywordflow}{return} a.second.size() < b.second.size(); \}}
\DoxyCodeLine{        );}
\end{DoxyCode}


In the last declaration (of an iterator to the item with the most common {\ttfamily char}) {\ttfamily max\+\_\+element} is {\ttfamily std\+::max\+\_\+element}. As most standard library functions that deal with collections, it takes a pair of iterators as arguments instead of directly taking the collection or something more abstract that represents the collection. The adoption of the {\itshape Ranges} library into the C++ standard library will address this, but for now – or even then, e.\+g. as a disambiguation technique – you can just use the {\itshape cppx-\/core} $\ast$$\ast${\ttfamily \$items}$\ast$$\ast$ macro.

“{\ttfamily \$items(char\+\_\+indices)}” effectively expands to “{\ttfamily std\+::begin(char\+\_\+indices),} {\ttfamily std\+::end(char\+\_\+indices)}”, except there\textquotesingle{}s a check to ensure that {\ttfamily char\+\_\+indices} is not an rvalue expression, because that could have made the macro call a function twice, then possibly repeating some side effect of that function. 