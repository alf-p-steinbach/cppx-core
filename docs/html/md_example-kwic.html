<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: example-kwic</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">example-kwic </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><b>Table of Contents</b> <em>generated with <a href="https://github.com/thlorenz/doctoc">DocToc</a></em></p>
<ul>
<li><a href="#example-a-kwic-like-greeting-program">Example: a KWIC-like greeting program</a><ul>
<li><a href="#1--the-ascii-based-variant">1 – The ASCII-based variant.</a></li>
<li><a href="#11---and-one-include-to-bind-them-all">1.1 – “… and one <code>#include</code> to bind them all”.</a></li>
<li><a href="#12--an-app-namespace">1.2 – An <code>app</code> namespace.</a></li>
<li><a href="#13--using-declaring-names-from-libraries">1.3 – <code>using</code>-declaring names from libraries.</a></li>
<li><a href="#14--throwing-an-exception-via-the-fail-macro">1.4 – Throwing an exception via the <code>$fail</code> macro.</a></li>
<li><a href="#15---using-the-cppx-core-support-for-signed-integer-arithmetic">1.5 – Using the <em>cppx-core</em> support for signed integer arithmetic.</a></li>
<li><a href="#16--using-the-cppx-core-ascii-support">1.6 – Using the <em>cppx-core</em> ASCII support.</a></li>
<li><a href="#17--the-items-macro">1.7 – The <code>$items</code> macro.</a></li>
</ul>
</li>
</ul>
<h1>Example: a KWIC-like greeting program</h1>
<p>This example is a possible code part of an answer on a Q&amp;A site such as Stack Overflow, or in a response in a technical discussion e.g. on Reddit.</p>
<p>The program (perhaps a student exercise) asks for the user's name and if that name contains one or more repeated characters it reports one that has the maximum count, as the most common character in the name, and then presents the name repeatedly but offset horizontally so that occurrences of that character line up vertically:</p>
<blockquote class="doxtable">
<p><code>&gt;&gt;&gt; The KWIC-like personal greeting program, using ASCII! &lt;&lt;&lt;</code></p>
<p><code>Hi, what's your name (in lowercase &amp; English letters only please)</code></p>
<p><code>?</code> <em><b>alfa bravo charlie</b></em></p>
<p><code>Oh hi, alfa bravo charlie! Nice to meet you!</code></p>
<p>&lsquo;The/a most common character in your name is 'a&rsquo;:`</p>
<p><code>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;|a|lfa bravo charlie</code></p>
<p><code>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;alf|a| bravo charlie</code></p>
<p><code>&#160;&#160;&#160;&#160;&#160;&#160;alfa br|a|vo charlie</code></p>
<p><code>alfa bravo ch|a|rlie</code></p>
<p></p>
</blockquote>
<p>The example interaction above is for the ASCII text encoding variant of the program. ASCII text uses only one byte per character, one <code>char</code> value per character, which gives simpler code than with the more general UTF-8 encoding. The UTF-8 based variant is slightly more complicated, and so even though I did that first here it's presented last.</p>
<p>By the way, “KWIC” means <em>key word in context</em>.</p>
<p>It was once a popular exercise for students, similar to this example, but with a key word lining up vertically instead of just a single character.</p>
<h2>1 – The ASCII-based variant.</h2>
<div class="fragment"><div class="line"><span class="comment">// → examples/kwic-greeting/kwic-greeting.ascii.cpp</span></div><div class="line"><span class="preprocessor">#include &lt;cppx-core/_all_.hpp&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>app</div><div class="line">{</div><div class="line">    $use_cppx(</div><div class="line">        Index, is_ascii_whitespace, is_empty, length_of, Map_, n_items_in, spaces</div><div class="line">        );</div><div class="line">    $use_std(</div><div class="line">        cin, cout, end, endl, getline, <span class="keywordtype">string</span>, string_view, max_element, vector</div><div class="line">        );</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> input() -&gt; <span class="keywordtype">string</span></div><div class="line">    {</div><div class="line">        <span class="keywordtype">string</span> result;</div><div class="line">        getline( cin, result )</div><div class="line">            or $fail( <span class="stringliteral">&quot;std::getline failed on std::cin&quot;</span> );</div><div class="line">        <span class="keywordflow">return</span> result;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">using</span> Char_indices = Map_&lt;char, vector&lt;Index&gt;&gt;;     <span class="comment">// “ASCII code point” → “indices”</span></div><div class="line"></div><div class="line">    <span class="keyword">auto</span> char_indices_in( <span class="keyword">const</span> string_view&amp; s )</div><div class="line">        -&gt; Char_indices</div><div class="line">    {</div><div class="line">        Char_indices result;</div><div class="line">        <span class="keywordflow">for</span>( Index i = 0; i &lt; length_of( s ); ++i )</div><div class="line">        {</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">char</span> ch = s[i];</div><div class="line">            <span class="keywordflow">if</span>( not is_ascii_whitespace( ch ) )</div><div class="line">            {</div><div class="line">                result[ch].push_back( i );</div><div class="line">            }</div><div class="line">        }</div><div class="line">        <span class="keywordflow">return</span> result;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> run()</div><div class="line">    {</div><div class="line">        cout &lt;&lt; <span class="stringliteral">&quot;&gt;&gt;&gt; The KWIC-like personal greeting program, using ASCII! &lt;&lt;&lt;&quot;</span> &lt;&lt; endl;</div><div class="line">        cout &lt;&lt; <span class="stringliteral">&quot;Hi, what&#39;s your name (in lowercase &amp; English letters only please)\n? &quot;</span>;</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">string</span> username = input();</div><div class="line"></div><div class="line">        <span class="keyword">const</span> Char_indices  char_indices    = char_indices_in( username );</div><div class="line">        <span class="keyword">const</span> <span class="keyword">auto</span>          it_most_common  = max_element( $items( char_indices ),</div><div class="line">            []( <span class="keyword">auto</span>&amp; a, <span class="keyword">auto</span>&amp; b ) { <span class="keywordflow">return</span> a.second.size() &lt; b.second.size(); }</div><div class="line">            );</div><div class="line"></div><div class="line">        cout &lt;&lt; endl;</div><div class="line">        <span class="keywordflow">if</span>( it_most_common == end( char_indices ) )     <span class="comment">// Username empty or all spaces.</span></div><div class="line">        {</div><div class="line">            cout &lt;&lt; <span class="stringliteral">&quot;Have a nice day!&quot;</span> &lt;&lt; endl;</div><div class="line">            <span class="keywordflow">return</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">char</span> ch       = it_most_common-&gt;first;</div><div class="line">        <span class="keyword">const</span> <span class="keyword">auto</span>&amp; indices = it_most_common-&gt;second;</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span>( n_items_in( indices ) == 1 )</div><div class="line">        {</div><div class="line">            cout &lt;&lt; <span class="stringliteral">&quot;All characters in your name are unique, &quot;</span> &lt;&lt; username &lt;&lt; <span class="stringliteral">&quot;.&quot;</span> &lt;&lt; endl;</div><div class="line">            <span class="keywordflow">return</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        cout &lt;&lt; <span class="stringliteral">&quot;Oh hi, &quot;</span> &lt;&lt; username &lt;&lt; <span class="stringliteral">&quot;! Nice to meet you!&quot;</span> &lt;&lt; endl;</div><div class="line">        cout &lt;&lt; <span class="stringliteral">&quot;The/a most common character in your name is &#39;&quot;</span> &lt;&lt; ch &lt;&lt; <span class="stringliteral">&quot;&#39;:&quot;</span> &lt;&lt; endl;</div><div class="line">        cout &lt;&lt; endl;</div><div class="line">        <span class="keyword">const</span> Index max_index = indices.back();</div><div class="line">        <span class="keywordflow">for</span>( <span class="keyword">const</span> Index i: indices )</div><div class="line">        {</div><div class="line">            cout    &lt;&lt; spaces( max_index - i )</div><div class="line">                    &lt;&lt; username.substr( 0, i )</div><div class="line">                    &lt;&lt; <span class="stringliteral">&quot;|&quot;</span> &lt;&lt; ch &lt;&lt; <span class="stringliteral">&quot;|&quot;</span></div><div class="line">                    &lt;&lt; username.substr( i + 1 )</div><div class="line">                    &lt;&lt; endl;</div><div class="line">        }</div><div class="line">    }</div><div class="line">}  <span class="comment">// namespace app</span></div><div class="line"></div><div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span></div><div class="line">{</div><div class="line">    $use_cppx( description_lines_from, monospaced_bullet_block );</div><div class="line">    $use_std( cerr, endl, exception, <span class="keywordtype">string</span> );</div><div class="line"></div><div class="line">    <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">        app::run();</div><div class="line">        <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">    }</div><div class="line">    <span class="keywordflow">catch</span>( <span class="keyword">const</span> exception&amp; x )</div><div class="line">    {</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">string</span> text = description_lines_from( x );</div><div class="line">        cerr &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span> &lt;&lt; monospaced_bullet_block( text, <span class="stringliteral">&quot;!&quot;</span> ) &lt;&lt; endl;</div><div class="line">    }</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">}</div></div><!-- fragment --><h2>1.1 – “… and one <code>#include</code> to bind them all”.</h2>
<p>Code:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cppx-core/_all_.hpp&gt;</span></div></div><!-- fragment --><p>This line includes everything from the library, including a guaranteed set of standard library headers.</p>
<p>Every folder in <em>cppx-core</em> has an <em><b>_all_.hpp</b></em> file that includes everything in that folder and subfolders. Thus, using the top level *_all_.hpp* file includes everything. You can include smaller subsets by including a sub-folder's *_all_.hpp*, or a specific header (they're all self-sufficient, with no requirements), or at the top level you can alternatively include <em><b>all-except-io.hpp</b></em>.</p>
<p>The guaranteed set of standard library headers is provided by</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cppx-core/stdlib-includes/basic-general.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cppx-core/stdlib-includes/basic-io.hpp&gt;</span></div></div><!-- fragment --><p>The non-i/o headers provided by <em>stdlib-includes/basic-general.hpp</em> are generally those that correspond to either C++ core langauge features, or to core language features in some other similar languages like Java and C#:</p>
<ul>
<li>*&lt;algorithm&gt;*, *&lt;array&gt;*, *&lt;atomic&gt;*, *&lt;chrono&gt;*, *&lt;deque&gt;*, *&lt;functional&gt;*, *&lt;initializer_list&gt;*, *&lt;iosfwd&gt;*, *&lt;iterator&gt;*, *&lt;map&gt;*, *&lt;memory&gt;*, *&lt;mutex&gt;*, *&lt;numeric&gt;*, *&lt;optional&gt;*, *&lt;queue&gt;*, *&lt;random&gt;*, *&lt;set&gt;*, *&lt;stack&gt;*, *&lt;stdexcept&gt;*, *&lt;string&gt;*, *&lt;string_view&gt;*, *&lt;thread&gt;*, *&lt;unordered_map&gt;*, *&lt;unordered_set&gt;*, *&lt;utility&gt;*, *&lt;vector&gt;*.</li>
</ul>
<p>The i/o headers provided by <em>stdlib-includes/basic-io.hpp</em> are just all the C++17 i/o headers, because there are just a few:</p>
<ul>
<li>*&lt;filesystem&gt;*, *&lt;fstream&gt;*, *&lt;iomanip&gt;*, *&lt;iostream&gt;*, *&lt;sstream&gt;*.</li>
</ul>
<p>Note: the *&lt;iostream&gt;* header guaranteed includes *&lt;ios&gt;*, *&lt;streambuf&gt;*, *&lt;istream&gt;* and *&lt;ostream&gt;*, so you get those too.</p>
<h2>1.2 – An <code>app</code> namespace.</h2>
<p>Code:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>app</div><div class="line">{</div><div class="line">    ⋮</div><div class="line">}  <span class="comment">// namespace app</span></div></div><!-- fragment --><p>With <em>cppx-core</em> it's easy to <code>using</code>-declare identifiers from other namespaces, and that's best done within your own namespace, not in the global namespace.</p>
<p>In particular, introducing identifiers directly into the global namespace can be problematic in a header.</p>
<p>So, in order to keep to good programming practices that work in general, I here use an <code>app</code> namespace for everything but the <code>main</code> function.</p>
<h2>1.3 – <code>using</code>-declaring names from libraries.</h2>
<p>Code:</p>
<div class="fragment"><div class="line">$use_cppx(</div><div class="line">    Index, is_ascii_whitespace, is_empty, length_of, Map_, n_items_in, spaces</div><div class="line">    );</div><div class="line">$use_std(</div><div class="line">    cin, cout, end, endl, getline, <span class="keywordtype">string</span>, string_view, max_element, vector</div><div class="line">    );</div></div><!-- fragment --><p>The **<code>$use_cppx</code>** macro is a more readable non-shouting alias for <code>CPPX_USE_CPPX</code>, and ditto, **<code>$use_std</code>** is a more readable non-shouting alias for <code>CPPX_USE_STD</code>. They <code>using</code>-declare the specified names, from respectively the <code>cppx</code> and <code>std</code> namespaces. The **<code>cppx</code> namespace** contains stuff from the <em>cppx-core</em> (and later also the <em>C++ Band Aid</em>) library, and the <code>std</code> namespace contains stuff from the C++ standard library.</p>
<p>Both macros are defined in terms of the more general <code>CPPX_USE_FROM_NAMESPACE</code>, alias **<code>$use_from_namespace</code>**, which you can use to <code>using</code>-declare names from other namespaces. There's also <code>CPPX_USE_NAMESPACE_NAME_IN</code>, alias **<code>$use_namespace_name_in</code>**, which you can use to <code>namespace</code>-declare the name of a nested namespace. These macros are provided by <em>syntax/macro-use.hpp</em>.</p>
<h2>1.4 – Throwing an exception via the <code>$fail</code> macro.</h2>
<p>Code:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> input() -&gt; <span class="keywordtype">string</span></div><div class="line">{</div><div class="line">    <span class="keywordtype">string</span> result;</div><div class="line">    getline( cin, result )</div><div class="line">        or $fail( <span class="stringliteral">&quot;std::getline failed on std::cin&quot;</span> );</div><div class="line">    <span class="keywordflow">return</span> result;</div><div class="line">}</div></div><!-- fragment --><p>By default **<code>$fail</code>** throws a <code>std::runtime_error</code> exception with the source code location embedded in the exception message as a second and indented line.</p>
<p><code>$fail</code> ends up using **<code>cppx::fail</code>** to throw the exception. And the <code>cppx::fail</code> function has <code>bool</code> return type, though it never returns!, in order to facilitate usage like the “<code>… or $fail</code>” pattern above. When it's used within a <code>catch</code> block then the current exception is nested via the standard C++11 mechanism.</p>
<p>In this example there's no exception nesting, and the message can look like this (here running the program in Windows):</p>
<blockquote class="doxtable">
<p><code>&gt;&gt;&gt; The KWIC-like personal greeting program, using ASCII! &lt;&lt;&lt;</code></p>
<p><code>Hi, what's your name (in lowercase &amp; English letters only please)</code></p>
<p><code>?</code> <em><b>^Z</b></em></p>
<p><code>!&#160;&#160;&#160;input - std::getline failed on std::cin</code></p>
<p><code>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&gt;File "kwic-greeting.ascii.cpp" at line 17</code></p>
<p></p>
</blockquote>
<p>The **<code>^Z</code>** is from typing a <code>Ctrl</code>+<code>Z</code>, which in Windows signifies end-of-text, like an end-of-file.</p>
<p>Fine point: in order to get straight ASCII quote characters, like **<code>"</code>**, I defined **<code>CPPX_USE_ASCII_PLEASE</code>** when I built the program. The default roundish UTF-8 encoded quote characters don't play well in an ordinary non-WSL Windows console window, even with active codepage 65001. Instead of the macro symbol definition I could have provided a custom <em>config.hpp</em> file via an include path override, or I could have edited the default one.</p>
<h2>1.5 – Using the <em>cppx-core</em> support for signed integer arithmetic.</h2>
<p>Code:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> Char_indices = Map_&lt;char, vector&lt;Index&gt;&gt;;</div></div><!-- fragment --><p>You can think of the <em>cppx-core</em> **<code>Map_</code>** class template as an alias for <code>std::unordered_map</code>. Actually it's a derived class in order to provide the missing <code>[]</code> indexing operator for a <code>const</code> <code>unordered_map</code> object, so more precisely it's like an alias for an <code>unordered_map</code> with more uniform access notation. So, a variable of type <code>Char_indices</code> is a set of pairs, where each pair contains a <code>char</code> value and a corresponding <code>vector</code> of indices.</p>
<p>The <em>cppx-core</em> **<code>Index</code>** type is an alias for the standard library's <code>ptrdiff_t</code> type. I.e. it's a signed index type of maximal practical range with a self-descriptive name. <em>cppx-core</em> also provides a signed size type called **<code>Size</code>**, that's also just an alias for <code>ptrdiff_t</code>. With signed types one avoids some nasty bugs associated with implicit conversions from signed to unsigned type, and resulting wrap-around to Really Large&trade; values. To avoid signed/unsigned mismatch warnings these types are supported by signed result functions such as **<code>n_items_of</code>** and (for strings) **<code>length_of</code>**.</p>
<h2>1.6 – Using the <em>cppx-core</em> ASCII support.</h2>
<p>Code:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> char_indices_in( <span class="keyword">const</span> string_view&amp; s )</div><div class="line">    -&gt; Char_indices</div><div class="line">{</div><div class="line">    Char_indices result;</div><div class="line">    <span class="keywordflow">for</span>( Index i = 0; i &lt; length_of( s ); ++i )</div><div class="line">    {</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">char</span> ch = s[i];</div><div class="line">        <span class="keywordflow">if</span>( not is_ascii_whitespace( ch ) )</div><div class="line">        {</div><div class="line">            result[ch].push_back( i );</div><div class="line">        }</div><div class="line">    }</div><div class="line">    <span class="keywordflow">return</span> result;</div><div class="line">}</div></div><!-- fragment --><p>The only new <em>cppx-core</em> thing in this snippet is the **<code>is_ascii_whitespace</code>** function. Other functions that provide ASCII support include <code>is_all_ascii_whitespace</code>, <code>is_ascii</code>, <code>is_all_ascii</code>, <code>wide_from_ascii</code>, <code>is_ascii_lowercase</code>, <code>is_ascii_uppercase</code>, <code>ascii_to_lowercase</code>, <code>ascii_to_uppercase</code>, and <code>ascii_quoted</code>. Since these functions are restricted to ASCII they're locale independent: you get the same results always.</p>
<p>I chose to express the above with an indexing loop using a classic <code>for</code>, computing each item value from the index. Alternatively the loop can be written as a range based <code>for</code> producing item references, and computing each index from the item reference. In the Python language one would naturally loop over the <code>enumerate</code>d pairs of item and index, but <em>cppx-core</em> doesn't offer that functionality: it may be provided in the future, or by the <em>C++ Band Aid</em> library.</p>
<h2>1.7 – The <code>$items</code> macro.</h2>
<p>Code:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> run()</div><div class="line">{</div><div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;&gt;&gt;&gt; The KWIC-like personal greeting program, using ASCII! &lt;&lt;&lt;&quot;</span> &lt;&lt; endl;</div><div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;Hi, what&#39;s your name (in lowercase &amp; English letters only please)\n? &quot;</span>;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">string</span> username = input();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> Char_indices  char_indices    = char_indices_in( username );</div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span>          it_most_common  = max_element( $items( char_indices ),</div><div class="line">        []( <span class="keyword">auto</span>&amp; a, <span class="keyword">auto</span>&amp; b ) { <span class="keywordflow">return</span> a.second.size() &lt; b.second.size(); }</div><div class="line">        );</div></div><!-- fragment --><p>In the last declaration (of an iterator to the item with the most common <code>char</code>) <code>max_element</code> is <code>std::max_element</code>. As most standard library functions that deal with collections, it takes a pair of iterators as arguments instead of directly taking the collection or something more abstract that represents the collection. The adoption of the <em>Ranges</em> library into the C++ standard library will address this, but for now – or even then, e.g. as a disambiguation technique – you can just use the <em>cppx-core</em> **<code>$items</code>** macro.</p>
<p>“<code>$items(char_indices)</code>” effectively expands to “<code>std::begin(char_indices),</code> <code>std::end(char_indices)</code>”, except there's a check to ensure that <code>char_indices</code> is not an rvalue expression, because that could have made the macro call a function twice, then possibly repeating some side effect of that function. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
